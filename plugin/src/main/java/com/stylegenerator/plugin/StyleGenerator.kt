package com.stylegenerator.plugin

import com.stylegenerator.plugin.util.FileUtil
import com.stylegenerator.plugin.util.StringUtil
import com.stylegenerator.plugin.util.StyleUtil
import com.stylegenerator.plugin.util.XMLUtil
import com.stylegenerator.plugin.util.addAttribute
import com.stylegenerator.plugin.util.addComment
import com.stylegenerator.plugin.util.addElement
import com.stylegenerator.plugin.util.addLineBreak
import org.w3c.dom.Document
import org.w3c.dom.Element
import java.io.File
import javax.xml.transform.TransformerException

/**
 * Class to create style file.
 */
internal class StyleGenerator(
        private val projectPath: String,
        private val fontNames: List<String> = emptyList(),
        private val colorNames: List<String> = emptyList(),
        private val parentStyle: String,
        private val generateUnusedStyles: Boolean,
        private val minTextSize: Int,
        private val maxTextSize: Int
) {

    private lateinit var doc: Document
    private lateinit var elementRoot: Element

    private val fileNameFilter: (File) -> Boolean = { file ->
        if (file.isDirectory) {
            file.name.contains("build")
        } else {
            !file.name.contains(".java")
                    && !file.name.contains(".kt")
                    && !file.name.contains(".xml")
        }
    }

    /**
     * Method to generate style definitions based on given fonts, colors and text sizes.
     */
    @Throws(Exception::class)
    fun generateResources() {
        // Remove old generated file
        val file = FileUtil.getFile(projectPath, OUTPUT_DIR, STYLE_FILE_NAME)
        file.delete()

        doc = XMLUtil.newDocument()
        elementRoot = doc.addElement(TAG_RESOURCE)

        elementRoot.addComment(doc, "Generated by Style Generator")
                .addLineBreak(doc)
        // Parent style
        val elementParentStyle = elementRoot.addElement(doc, TAG_STYLE)
                .addAttribute("name", StyleUtil.STYLE_NAME_PREFIX)
                .addAttribute("parent", parentStyle)

        elementRoot.addElement(elementParentStyle)
                .addLineBreak(doc)

        for (fontName in fontNames) {

            if (generateUnusedStyles || isStyleUsed(fontName)) {

                // Add comment
                elementRoot.addComment(doc, "${StringUtil.convertCamelCase(fontName)} Styles")
                        .addLineBreak(doc)

                createStyle(fontName)

                for (colorName in colorNames) {

                    if (generateUnusedStyles || isStyleUsed(fontName, colorName)) {

                        createStyle(fontName, colorName)

                        for (textSize in minTextSize..maxTextSize) {

                            if (generateUnusedStyles || isStyleUsed(fontName, colorName, textSize)) {

                                createStyle(fontName, colorName, textSize)
                            }
                        }
                    }
                }
            }
        }

        createFile(doc)
    }

    private fun isStyleUsed(vararg styleNameParams: Any): Boolean {
        return FileUtil.contains(
                projectPath,
                StyleUtil.getStyleName(*styleNameParams),
                StyleUtil.getStyleName(*styleNameParams, separator = "_"),
                fileFilter = fileNameFilter
        )
    }

    private fun createStyle(fontName: String) {
        val elementStyle = elementRoot.addElement(doc, TAG_STYLE)
                .addAttribute("name", StyleUtil.getStyleName(fontName))
                .addElement(createItemElement(StyleUtil.ItemTagType.FONT, fontName))
        elementRoot.addElement(elementStyle)
                .addLineBreak(doc)
    }

    private fun createStyle(fontName: String, colorName: String) {
        val elementStyle = elementRoot.addElement(doc, TAG_STYLE)
                .addAttribute("name", StyleUtil.getStyleName(fontName, colorName))
                .addElement(createItemElement(StyleUtil.ItemTagType.COLOR, colorName))
        elementRoot.addElement(elementStyle)
                .addLineBreak(doc)
    }

    private fun createStyle(fontName: String, colorName: String, textSize: Int) {
        val elementStyle = elementRoot.addElement(doc, TAG_STYLE)
                .addAttribute("name", StyleUtil.getStyleName(fontName, colorName, textSize))
                .addElement(createItemElement(StyleUtil.ItemTagType.SIZE, textSize))
        elementRoot.addElement(elementStyle)
                .addLineBreak(doc)
    }

    private fun createItemElement(itemTagType: StyleUtil.ItemTagType, value: Any): Element {
        return doc.addElement(TAG_ITEM, false)
                .addAttribute("name", StyleUtil.getItemName(itemTagType))
                .addElement(doc.createTextNode(StyleUtil.getItemValue(itemTagType, value)))
    }

    /**
     * Method to create xml file.
     */
    @Throws(TransformerException::class)
    private fun createFile(doc: Document) {

        val file = FileUtil.getFile(projectPath, OUTPUT_DIR, STYLE_FILE_NAME)

        XMLUtil.writeToFile(doc, file)
    }

    companion object {
        private const val OUTPUT_DIR = "src/main/res/values"

        private const val STYLE_FILE_NAME = "styles_text_appearance.xml"

        private const val TAG_RESOURCE = "resources"
        private const val TAG_STYLE = "style"
        private const val TAG_ITEM = "item"
    }
}
